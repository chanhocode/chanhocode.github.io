---
title: "[Study] Build a Larage Language Model 02: Working with text data"
writer: chanho
date: 2025-08-19 21:30:00 +0900
categories: [Study, Book_Build_a_Large_Language_Model]
tags: [ai, llm, book, study]
---

> 이번 스터디에서는 "Build a Large Language Model" 책의 Part 2를 다루며, LLM이 텍스트 데이터를 어떻게 처리하고 이해하는지 살펴보았다. 텍스트를 벡터로 변환하는 임베딩 과정부터 토큰화, 위치 인코딩까지 LLM의 핵심 전처리 단계를 분석했다.
> 

# Chapter 2: Working with text data

LLM은 인간의 언어를 직접 이해할 수 없다. 텍스트를 신경망이 처리할 수 있는 숫자 벡터로 변환하는 과정이 필수적인데, 이를 **임베딩(Embedding)**이라고 한다. 이번 챕터에서는 원시 텍스트가 LLM의 입력으로 변환되는 전체 파이프라인을 살펴보았다.

## 텍스트 데이터 처리 파이프라인

LLM이 텍스트를 처리하는 과정은 다음과 같은 단계로 이루어진다:

```
원시 텍스트 → 토큰화된 텍스트 → 토큰 ID → 토큰 임베딩 → LLM 처리 → 출력 텍스트
```

### 1. 토큰화 (Tokenizing)

토큰화는 연속된 텍스트를 모델이 처리할 수 있는 개별 단위인 토큰(token)으로 분할하는 과정이다. 토큰은 단어, 하위 단어(subword), 또는 문자일 수 있다.

GPT-2, GPT-3와 같은 현대 LLM에서는 BPE(Byte Pair Encoding) 알고리즘을 주로 사용한다. BPE는 다음과 같은 특징을 가진다:

- **데이터 기반 접근법**: 말뭉치에서 가장 빈번하게 등장하는 문자 쌍을 반복적으로 병합하여 어휘를 구축한다.
- **하위 단어 분할**: 어휘에 없는 단어를 더 작은 의미 단위로 분해한다. 예를 들어 "unhappiness"를 "un", "happiness"로 분할한다.
- **OOV 문제 해결**: 어휘 사전에 없는 단어도 개별 문자 수준까지 분해하여 표현할 수 있어 `<|unk|>` 같은 특수 토큰이 불필요하다.

그러나 BPE에는 몇 가지 한계점도 존재한다. BPE는 통계적 빈도에만 기반하기 때문에 형태론적으로 중요한 경계를 무시할 수 있다. 그리고 대규모 말뭉치에서 빈도 계산과 병합 과정은 상당한 연산량이 필요하다.

+ BPE 외의 다른 토큰화 기법

- WordPiece: BERT, DistilBERT 등에서 사용하는 토큰화 방식으로, BPE와 매우 유사하다. 가장 빈번한 쌍을 병합하는 BPE와 달리, WordPiece는 어휘 사전에 추가되었을 때 말뭉치의 우도(likelihood)를 가장 높이는 토큰을 병합한다. 단어의 시작 부분에 “##” 접두사를 붙여 하위 단어임을 명시하는 특징이 있다.
- Unigram Language Model: T5, ALBERT, XLNet 등에서 사용됩니다. BPE나 WordPiece처럼 점진적으로 병합하는 것이 아니라, 큰 어휘 사전으로 시작해 확률적으로 손실을 계산하며 불필요한 토큰을 점차 제거하는 방식이다. 이를 통해 하나의 단어가 여러 방식으로 토큰화될 수 있는 가능성을 열어두어 모델의 강건성을 높일수 있다.

### 2. 특수 토큰 추가 (Special Tokens)

모델의 이해를 돕고 특정 문맥을 처리하기 위해 어휘 사전에 특별한 의미를 가진 토큰들을 추가할 수 있다.

- `<|endoftext|>`: 텍스트의 끝을 표시하여 서로 다른 문서 간의 경계를 명확히 한다.
- `<|BOS|>` (Beginning of Sequence): 시퀀스의 시작을 표시한다.
- `<|EOS|>` (End of Sequence): 시퀀스의 끝을 표시한다.
- `<|PAD|>` (Padding): 배치 처리 시 모든 시퀀스의 길이를 동일하게 맞추기 위해 사용된다.

### 3. 토큰 ID 변환 (Token IDs)

토큰화된 텍스트는 모델의 어휘 사전을 참조하여 고유한 정수 ID로 변환된다.

1. 각 토큰에 대해 어휘 사전에서 해당 토큰의 인덱스(ID)를 찾는다.
2. 이 ID는 모델 내부에서 토큰을 식별하는 데 사용된다.
3. 생성된 텍스트를 다시 사람이 읽을 수 있는 형태로 변환할 때(디코딩), 이 ID를 역으로 참조하여 원래 토큰을 복원한다.

예를 들어, "Hello world"라는 텍스트가 ["Hello", "world"]로 토큰화되고, 어휘 사전에서 각각 ID 15와 27로 매핑될 수 있다.

### 4. 데이터 샘플링 (Sliding Window)

LLM 훈련을 위해 **슬라이딩 윈도우(Sliding Window)** 기법을 사용하여 입력-목표 쌍을 생성한다.

```
입력(x): [15, 27, 42, 8]
목표(y): [27, 42, 8, 19]
```

이 방식은 모델이 주어진 문맥(`x`)에서 다음 토큰(`y`)을 예측하는 방식으로 학습하게 한다. 이러한 자기회귀적(autoregressive) 학습 방식은 GPT와 같은 생성형 모델의 핵심 훈련 방법이다.

### 5. 토큰 임베딩 및 위치 인코딩

### 토큰 임베딩 (Token Embeddings)

토큰 ID를 신경망이 처리할 수 있는 고밀도 벡터(dense vector)로 변환한다.

1. 모델 내부에 임베딩 행렬(Embedding Matrix)이 있으며, 크기는 (어휘 크기 × 임베딩 차원)이다.
2. 각 토큰 ID에 대해 임베딩 행렬에서 해당 행을 조회(lookup)하여 임베딩 벡터를 얻는다.
3. 이 과정은 PyTorch의 ‘nn.Embedding’ 계층을 통해 구현된다.

실제로 임베딩 계층은 단순한 조회 테이블로 작동한다. 예를 들어, 어휘 크기가 6이고 임베딩 차원이 3인 경우, 임베딩 행렬은 6×3 크기를 가진다. 토큰 ID 시퀀스 [2, 3, 5, 1]에 대한 임베딩은 각 ID에 해당하는 행을 조회하여 4×3 크기의 행렬로 변환된다.

```python
# 임베딩 행렬 예시 (6x3 크기)
embedding_matrix = [
    [0.1, 0.2, 0.3],  # ID 0의 임베딩 벡터
    [0.4, 0.5, 0.6],  # ID 1의 임베딩 벡터
    [0.7, 0.8, 0.9],  # ID 2의 임베딩 벡터
    [1.0, 1.1, 1.2],  # ID 3의 임베딩 벡터
    [1.3, 1.4, 1.5],  # ID 4의 임베딩 벡터
    [1.6, 1.7, 1.8]   # ID 5의 임베딩 벡터
]

# 토큰 ID 시퀀스 [2, 3, 5, 1]에 대한 임베딩 조회
token_embeddings = [
    embedding_matrix[2],  # [0.7, 0.8, 0.9]
    embedding_matrix[3],  # [1.0, 1.1, 1.2]
    embedding_matrix[5],  # [1.6, 1.7, 1.8]
    embedding_matrix[1]   # [0.4, 0.5, 0.6]
]

# 결과: 4x3 크기의 행렬
# [
#   [0.7, 0.8, 0.9],
#   [1.0, 1.1, 1.2],
#   [1.6, 1.7, 1.8],
#   [0.4, 0.5, 0.6]
# ]
```

+ 임베딩의 목적: “왜 고밀도 벡터(Dense Vector)를 사용하는가?”

- 원-핫 인코딩(One-Hot Encoding)과의 비교: 초기 자연어 처리에서는 단어를 원-핫 벡터로 표현했다. 이는 어휘 사전 크기와 동일한 차원을 가지며, 해당 단어의 인덱스만 1이고 나머지는 모두 0인 희소 벡터이다.
- 단점
    - 차원의 저주: 어휘 수가 수만 개에 달하면 벡터의 차원이 너무 커져 계산 비효율성을 야기한다.
    - 의미 관계 표현 불가: 모든 단어 벡터가 서로 직교하므로, '강아지'와 '고양이'처럼 의미가 비슷한 단어라도 그 관계를 표현할 수 없다.
- 해결책: 토큰 임베딩은 단어의 의미를 저차원의 고밀도 벡터(예: 256, 768, 4096차원)에 압축하여 표현함으로써 위 문제들을 해결하고, 벡터 공간에서 단어 간의 의미적 유사성을 거리로 표현할 수 있게 한다.

### 위치 임베딩 (Positional Embeddings)

토큰 임베딩만으로는 단어의 순서 정보를 표현할 수 없기 때문에, 위치 임베딩(Positional Embedding)을 추가한다.

1. **절대 위치 임베딩(Absolute Positional Embedding)**
    - 각 위치(인덱스)에 고유한 벡터를 할당한다.
    - OpenAI의 GPT 모델들은 이 방식을 사용한다.
        - 학습 가능한 임베딩(Learned Embeddings): GPT가 사용하는 방식이다. 각 위치 인덱스(0, 1, 2, ...)에 대해 임베딩 벡터를 하나씩 할당하고, 이 벡터들을 모델 학습 과정에서 다른 가중치와 함께 훈련시킨다.
2. **상대 위치 임베딩(Relative Positional Embedding)**
    - 토큰 간의 상대적 거리에 기반한 임베딩을 사용한다.
    - 다양한 길이의 시퀀스에 더 잘 일반화된다.
    - RoPE(Rotary Positional Embedding)와 같이 토큰 간의 상대적인 거리에 따라 어텐션 스코어를 조절하는 방식들이 있으며, 최근 LLM에서 많이 채택되고 있다.

최종적으로 토큰 임베딩과 위치 임베딩을 더하여 모델의 입력으로 사용한다:

```
최종 임베딩 = 토큰 임베딩 + 위치 임베딩
```

---

### **💡** 현 시점에는 다중 임베딩 모델(multimodal embedding model)이 있는가?

**A**: 현재 AI 연구의 주요 트렌드 중 하나는 **멀티모달(multimodal) 임베딩 모델**이다. 이러한 모델들은 텍스트, 이미지, 오디오, 비디오 등 다양한 데이터 유형을 동일한 벡터 공간에 매핑하여 서로 다른 모달리티 간의 관계를 이해할 수 있게 한다.

- CLIP(Contrastive Language-Image Pre-Training)은 대표적인 멀티모달 임베딩 모델로, 텍스트와 이미지를 동일한 벡터 공간에 매핑한다. CLIP은 비전 인코더(ViT)와 텍스트 인코더로 구성되어 있으며, 텍스트만 입력해도 임베딩이 가능하다. 이 텍스트 임베딩은 이미지 임베딩과 동일한 벡터 공간에 존재하므로, 텍스트 설명과 가장 일치하는 이미지를 찾는 등의 작업에 활용할 수 있다.

**DALL-E, Gemini, GPT-4o**와 같은 생성형 모델도 임베딩 모델로 분류할 수 있다. 이들은 내부적으로 다양한 모달리티의 데이터를 공통된 임베딩 공간으로 변환하는 인코더를 포함하고 있기 때문이다. 특히:

- **DALL-E**: 텍스트 프롬프트를 이미지 생성에 활용하기 위해 텍스트 임베딩을 생성하고, 이를 이미지 생성 과정의 조건으로 사용한다.
- **Gemini, GPT-4o**: 이들은 텍스트, 이미지, 오디오 등 다양한 입력을 처리할 수 있는 네이티브 멀티모달 모델로, 내부적으로 각 모달리티를 공통된 표현 공간으로 변환하는 인코더를 포함한다.

### **💡** Word2Vec 외에 다른 단어 임베딩 예시들은 무엇이 있는가?

**A**: Word2Vec 이외에도 다양한 단어 임베딩 기법들이 개발되었다:

1. **GloVe (Global Vectors for Word Representation)**:
    - 단어 동시 등장 통계(co-occurrence statistics)를 활용한 임베딩 방법이다.
    - Word2Vec이 지역적 문맥(local context)에 초점을 맞춘다면, GloVe는 전체 말뭉치의 통계 정보를 활용한다.
    - 단어 간의 유사성과 유추 관계(analogies)를 잘 포착한다.
    - 예: "king - man + woman ≈ queen"과 같은 벡터 연산이 가능하다.
2. **FastText**:
    - Word2Vec의 확장 버전으로, 단어를 문자 n-gram의 집합으로 표현한다.
    - 예: "apple"을 "<ap", "app", "ppl", "ple", "le>"와 같은 n-gram으로 분해한다.
    - 형태적으로 유사한 단어에 대해 더 나은 표현을 제공한다.
    - 어휘 외 단어(OOV)에 대해서도 임베딩을 생성할 수 있어 희귀 단어나 오타에 강건하다.
3. **ELMo (Embeddings from Language Models)**:
    - 문맥화된(contextualized) 단어 임베딩을 제공하는 첫 주요 모델 중 하나이다.
    - 양방향 LSTM을 사용하여 단어의 문맥을 고려한 표현을 생성한다.
    - 동음이의어(homonyms) 문제를 해결한다. 예: "bank"(은행)와 "bank"(강둑)는 문맥에 따라 다른 임베딩을 갖는다.

### **💡** BPE(Byte Pair Encoding)의 단점은 무엇인가?

**A**: BPE는 효율적인 토큰화 방법이지만 다음과 같은 한계점을 가진다:

1. **의미론적 경계 무시**: BPE는 오직 데이터의 통계적 빈도에 기반하여 토큰을 병합한다. 이로 인해 'un-happily'와 같이 의미론적으로나 형태론적으로 중요한 경계를 무시하고 토큰을 병합할 수 있다.
